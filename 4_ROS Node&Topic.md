# ROS Node&Topic

## ROS节点 Node

在ros中，最小的进程单元就是节点node

软件包中有多个可执行文件，运行这些文件就形成了一个个进程，这些进程在ROS中叫做节点

从程序角度来说，node就是一个可执行文件（通常为C++编译生成的可执行文件、Python脚本）被执行，加载到了内存之中

从功能角度来说，通常一个node负责者机器人的某一个单独的功能。由于机器人的功能模块非常复杂，我们往往不会把所有功能都集中到一个node上，而会采用分布式的方式，把鸡蛋放到不同的篮子里

例如有一个node来控制底盘轮子的运动，有一个node驱动摄像头获取图像，有一个node驱动激光雷达，有一个node根据传感器信息进行路径规划，这样做可以降低程序发生崩溃的可能性，试想一下如果把所有功能都写到一个程序中，模块间的通信、异常处理将会很麻烦。

### 节点文件位置

一般来说.cpp文件放在功能包的src目录下，Python脚本放在scripts目录下



### ROS节点的功能

**发布（Publishing）和订阅（Subscribing）话题（Topics）**：

节点可以发布消息到话题，或订阅话题以接收消息。

这是节点间通信的主要方式，用于传输传感器数据、状态信息、控制命令等。

**提供（Providing）和使用（Using）服务（Services）**：

服务是另一种节点间通信方式，允许节点对另一个节点进行同步的请求和响应。

例如，一个节点可以请求另一个节点提供的服务来执行某项操作或计算。

**配置和使用参数（Parameters）**：

节点可以使用ROS参数服务器存储和检索配置信息。

参数可以在运行时设置和修改，允许动态调整节点行为。

**动态重配置（Dynamic Reconfigure）**：

一些节点支持动态重配置，允许在运行时改变参数而不需要重启节点。

这对于调整算法参数或系统行为特别有用。

**记录和回放（Logging and Playback）**：

节点可以使用ROS的记录功能（如rosbag）记录运行时的数据，包括话题消息和服务调用，然后在以后回放这些数据进行调试或数据分析。

**使用tf库进行坐标变换（Coordinate Transformations）**：

节点可以使用tf库管理和转换不同坐标系之间的关系，这对于机器人的导航和感知特别重要。

### 编写一个节点

#### 创建一个talker节点作为publisher

```c++
#include"ros/ros.h"
#include"std_msgs/String.h"
```

这两行是预处理指令，用于包含ROS和标准消息库的头文件。ros/ros.h是ROS的主要头文件，提供了ROS程序中常用的核心功能。std_msgs/String.h是标准消息类型String的头文件，用于节点间的字符串通信。

如果您的 Python 脚本的第一行不是 shebang（如 `#!/usr/bin/env python` 或 `#!/usr/bin/env python3`），那么操作系统可能不知道应该用 Python 解释器来执行这个脚本。确保脚本的第一行正确地指向了 Python 解释器。

```c++
int main(intargc,char**argv){
    #这行定义了主函数，它是程序的入口点。argc和argv是传递给程序的命令行参数的数量和值。
	ros::init(argc, argv,"talker");
    #这行调用ros::init()函数来初始化ROS。它接受命令行参数，并设置节点的名称，这里节点的名称被设置为"talker"。
	ros::NodeHandle n;
    #这行创建一个NodeHandle实例，是与ROS系统通信的主要接口。你可以通过这个NodeHandle实例来创建发布者、订阅者、服务等。当你创建一个ros::NodeHandle实例时，你实际上在为你的节点建立一个通信的上下文。
	ros::Publisher chatter_pub = n.advertise("chatter",1000);
    #这行创建了一个发布者chatter_pub，它可以向"chatter"话题发布std_msgs::String类型的消息。1000是发布队列的大小，它定义了在达到发送给订阅者之前，消息可以积累的数量。可看作一个缓冲池
	ros::Rateloop_rate(10);
    #这行创建了一个Rate对象，用于定义循环的频率。这里设置为10Hz，意味着循环体将尽可能保持每秒10次的执行频率。
	while(ros::ok()) {
        #这行开始了一个循环，它将持续执行，直到收到ROS的关闭信号（例如，通过Ctrl+C）。
		std_msgs::String msg;
        #在循环内部，首先创建一个String类型的消息msg。
		msg.data ="hello world";
        #这行将字符串"hello world"赋值给消息的data字段。
		chatter_pub.publish(msg);
        #这行发布消息到"chatter"话题。
		ros::spinOnce();
        #这行调用spinOnce()函数，它是非阻塞版本的spin()，允许一次调用回调函数（如果有的话）。这在需要持续执行其他操作的循环中很有用。
		loop_rate.sleep();
        #这行使得循环遵循设定的10Hz频率，如果需要，它会让当前线程睡眠以保持循环频率。
		return 0;
	}
}
```

#### 修改CMakeLists.txt

为了编译节点，需要修改CMakeLists.txt文件，告诉catkin如何构建代码

##### 在add_executable和target_link_libraries中添加节点：

`add_executable(talker src/talker.cpp)`

talker：这是生成的可执行文件的名称。

src/talker.cpp：这指定了源代码文件的位置。

` target_link_libraries(talker ${catkin_LIBRARIES})`

talker：这是你之前用add_executable命令创建的目标可执行文件的名称。在这个上下文中，它指的是你希望链接库的可执行文件。

`${catkin_LIBRARIES}：`这是一个变量，代表了所有catkin组件库的集合。当你在find_package(catkin REQUIRED COMPONENTS ...)中列出ROS组件时，catkin会将这些组件的库链接到${catkin_LIBRARIES}变量。这样，你就可以确保你的程序链接到了所有必要的ROS库。

##### 确保在编译节点之前先生成必要的消息或服务代码。

`add_dependencies(talker <package_name>_generate_messages_cpp)`

talker：这是你要编译的目标，即你的节点，该节点依赖于自定义消息或服务时，你需要确保这些消息或服务的代码在编译该节点之前已经生成。

<package_name>__generate_messages_cpp：这是一个自动生成的依赖项，它代表了你的包中定义的所有消息和服务的C++代码生成任务。这个名称遵循一个特定的格式：<package_name>_generate_messages_cpp。

##### rosnode常用名令

`rosnode list`: 列出当前活动的所有节点。

`rosnode info <node_name>`：显示关于特定节点的信息，如订阅的话题、发布的话题、服务等。

`rosnode ping <node_name>`：测试节点是否响应，以检查它是否活动。

## ROS Topic

ROS中的话题通信机制是一种基于发布/订阅模式的通信方式，使得节点能够相互独立地发送和接收消息。这种机制是ROS中实现模块化和解耦合的关键部分，允许不同的节点在没有直接知道对方存在的情况下交换数据。

话题通信使用的消息（Messages）是定义好的数据结构，用于节点之间的数据交换。消息使得发布者和订阅者之间可以共享结构化的数据，比如传感器的读数、状态信息、控制命令等。

### 发布者和订阅者

**发布者（Publisher）**：**一个节点可以成为一个或多个话题的发布者**。发布者节点向特定的话题发送消息，这些消息可以是传感器数据、状态信息、控制命令等。

**订阅者（Subscriber）**：**一个节点可以订阅一个或多个话题**。当订阅的话题有新消息时，订阅者节点会接收这些消息，并可以根据接收到的数据执行相应的处理。

### 话题通信的工作流程

**节点启动**：节点开始运行，初始化ROS客户端库。

**声明发布者和订阅者**：

发布者节点声明它将发布到哪个话题，以及使用的消息类型。

订阅者节点声明它想要订阅的话题和消息类型，以及定义一个回调函数来处理接收到的消息。

**名称解析**：ROS Master帮助节点解析话题名称，确保发布者和订阅者对应同一个话题。

**通信建立**：一旦订阅者和发布者匹配，它们之间的连接就会建立。订阅者会直接从发布者接收消息，而不需要经过中央服务器。

**消息传递**：发布者节点将消息发布到话题，所有订阅该话题的节点都将接收这些消息并调用设定的回调函数进行处理。

特点和优势

**解耦合**：发布者和订阅者不需要知道对方的存在，它们只关心消息和话题，这增强了系统的模块性和可扩展性。

**灵活性**：可以随时添加或移除发布者和订阅者，不影响其他节点。

**多对多通信**：多个发布者可以发布到同一个话题，多个订阅者可以订阅同一个话题，实现复杂的通信模式。

**异步通信**：发布者和订阅者之间的通信是异步的，允许节点独立地以自己的频率工作。

通过这种通信机制，ROS支持复杂的数据交换和节点间的协作，为构建高度复杂且互联的机器人系统提供了基础。